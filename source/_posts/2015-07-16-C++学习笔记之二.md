---
title:        "C++学习笔记之二"
date:         2015-7-16 17:00
categories:   C++
tags:
- C++
---

阅读 《C++Primer 第四版》第四章 数组和指针 所做的一些笔记。
加入了一些C\++11的特性。

<!--more-->

### 数组

数组的优势在于速度快，缺点在于没有vector的可伸缩性也没有类似size()的函数。

#### 数组的定义和初始化
定义数组时数组的维度必须是一个常量表达式，即要在编译器就可以确定的值。例如：
```cpp
const unsigned array_size = 3;
int a[array_size] = {0, 1, 2};
```
关于数组中元素的初始化：
* 函数体外定义的内置数组（内置数组就是C++内置的基本类型的数组），其元素均初始化为0
* 函数体内部的内置数组，则不做初始化
* 类类型的数组会自动调用无参构造方法，如果该类没有无参构造方法则需要在初始化的时候显示的初始化元素

显示初始化数组时不需要指定数组维度。
```cpp
int i[] = {1, 2, 3};
```
初始化字符数组有些不同：

```cpp
char c1[] = {'c', '+', '+'};  // length 3
char c2[] = {'c', '+', '+', '\0'}; // length 4
char c3[] = "c++";   // length 4
char c4[3] = "c++";  // error
```
c2和c3是结果是一样的，当用c3这种方式初始化char数组的时候，编译器会自动加入结束符，如果用c2的方式初始化就需要手动加一个结束符，像c1那样的初始化并不带结束符，打印输出的时候末尾会出现一些奇怪的字符。像c4初始化的时候维度应该是4不是3。

与vector不同一个数组不能用于另一个数组的初始化，也不能将一个数组赋值给另一个数组，例如：
```cpp
int i1[] = {1, 2, 3};
int i2[](i1); //error
int i3[3];
i3 = i1; //error
```
书上说有些编译器支持数组赋值数组（我尝试了g++和vs都不支持）。

#### 数组的操作
C++中的数组和java中的有一些区别，例如没办法直接拿到数组的长度。赋值能操作还是一样的。测量数组长度的方法如下。
```cpp
int aa[] = {1,2,3,4,5,6,7,8,9,0};
cout << sizeof(aa) / sizeof(int) << endl;
```
在C++中优先使用容器类，如果遇到必须数组才能解决的问题（例如性能）的时候再考虑用数组。

### 指针

指针用于指向对象，具体来说，指针保存了另一个对象的地址（和汇编中的立即寻址很像）：
```cpp
string s = "hahaha";
string *sp = &s;
```
&符号的意思是取地址，当他作用于一个对象的时候返回的是该对象存储的地址，取地址操作只能用于左值。


#### 指针的定义和初始化
常规风格：
```cpp
vector<int> *pvec;  //指向一个 vector<int> 对象
int *ip1, *ip2;     //指向 int 值
string *ps;         //指向string 对象
double dp1, *dp2;   // dp1是一个double值， *dp2是一个double值的指针
```
另一种风格：
```cpp
int* pi, i; // pi是个指针，i不是指针
int* pi1, *pi2;  //两个都是指针
```
个人还是习惯常规风格。

#### 指针的取值
未初始化的指针是无效的：
* 保存一个特定对象的地址
* 指向某个对象后面的另一个对象
* 0

```cpp
int ival = 1024;
int *pi = 0;  //不指向任何对象
int *pi2 = &ival //指向1024. pi2是ival的地址
int *pi3;  //未初始化的指针
pi = pi2;  // 指向同一个对象
pi2 = 0;   // 不指向任何对象，这里的0也可以是个常量表达式只要结果为0即可
pi2 = NULL; //等价于pi2 = 0
pi2 = nullptr; // C++11中加入的空指针字面量
```
C\++规范中并没有说明使用未初始化的指针会有什么问题，但是使用未初始化的指针式很危险的，未初始化的指针可能指向任意一个地址，当使用这个指针指向的数据时很有可能崩溃。测试vs2013中，未初始化的指针是会报编译期错误，g\++中没有报错并且运行会打印一个地址。

总结一下对指针的理解：
```cpp
int i = 1;
int *pi = &i;  // pi的类型是int *也就是int指针,i的类型是int，指针类型中保存的被指向对象的地址，根据实际测试发现&i返回的就是int *类型。
```

#### void指针
void指针可以保存任何对象的地址：
```cpp
int i = 1;
void *vp = &i;
char *cp = "123456";
cout << cp << endl;   // 按理来说输出cp的地址，但是cout对这的处理是输出了整个数组
void *vp = cp;  
cout << vp << endl;   // 对于 char *类型，cout会认为是一个c-style的string所以直接用的话不会输出地址
```
void指针并不清楚她保存的指针的对象类型，而且只支持有限的几个指针操作：
* 与另一个指针比较
* 传递函数指针
* 赋值给另一个void指针

#### 指针的操作
*操作符（解引操作符）将获取指针指向的对象：
```cpp
int *p = 0;
cout << *p << endl; // 程序崩溃
cout << p << endl;  // 指针地址 00000000

string str("sss");  // 初始化一个字符串
string *sp = &str;
*sp = "asasda";     //*操作符（解引操作符）拿到的是str这个对象
```

#### 指针和数组
C\++中的数组编译器一般会把它转换成指针。例如：
```cpp
int nums[] = {1, 2, 3, 4, 5, 6};
int *p = &nums[0]; // p指针指向数组的第一个元素
int *p2 = nums;    // 等价于上面
```

#### 指针也是迭代器
与vector和string的迭代器一样，数组的指针也支持相应的运算。例如：
```cpp
int arr[] = {1, 2, 3, 4};
int *p = arr;
p++;
cout << *p << endl;   // print 2

for(int *a = arr; a != &arr[4]; a++)
{
    cout << *a << endl;   // 这里的&arr[4]类似于迭代器的end()，拿到的是最后一个元素之后的位置
}
```
C\++11中加入了更方便的方法来使用数组指针：
```cpp
int arr[] = {1, 2, 3, 4};
int *b = begin(arr);  // C++11中新加入的获取数组头指针的方法
int *e = end(arr);    // C++11中新加入的获取数组尾后指针的方法

while(b != e)
{
    cout << *b << endl;
    b++;
}
```

#### 指针的运算
指针的运算主要是对地址的操作和对指向对象的运算。

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;    //第一个元素的指针
int *p1 = *p + 4;    // 等价于arr[4]
int *p2 = arr + 4;   // 当直接使用arr的时候编译器会自动将arr转换成指向第一个元素的指针
int *p3 = arr + 10;  // 虽然数组越界了但是会返回一个那个位置上的一个数，值不确定，而不会像java等语言抛出数组越界的错误

auto size =  end(arr) - begin(arr);  //计算数组大小
```

指向同一个数组的两个指针可以使用比较运算符运算：
```cpp
int arr[4] = {1, 2, 3, 4};
int *b = begin(arr), *e = end(arr);
while(b < e)  //这里就可以比较运算
    b++;

int i1 = 3, *p = &i1;
int i2 = 3, *p1 = &i2;

bool a = p < p1;   //这样比较没什么意义 最终比较的是两个指针的地址

```

#### 下标和指针
一个例子：
```cpp
int a[3] = {1, 2, 3};

int *p = &a[2];

int i1 = p[1]；  //p[1] 相当于 *(p + 1)
int i2 = p[-1];  //p[-1] 相当于 *(p - 1)
```
在数组中下标是一个无符号的数，而如果作为指针来使用就可以用正负值来移动指针

#### C风格的字符串
C\++支持C风格的字符串，但是尽量不要使用他们，因为他们不仅使用起来不方便而且容易出现安全漏洞。
C\++中C风格字符串的相关函数在cstring这个头文件中，相关的函数有：
```cpp
strlen(p) //返回p字符串的长度，不包含空字符
strcmp(p1, p2)  //比较两个字符串
strcat(p1, p2)  //把p2加在p1之后然后返回p1
strcpy(p1, p2)  //p2复制给p1
```
在使用中会出现p1的长度不容易估计，不够灵活的情况。和string相比，char是个基本类型，string是个类，不同编译器对类编译的结果不同，这就造成了在share lib的时候string只能用于内部，对外接口需要转换成char。

string和char之间的转换：
```cpp
char c1[] = "12345";
string s1(c1);   //char array to string
const char *s2 = s1.c_str();  //string to char*
string s2 = c1;  //这是错误的
```
数组和vector之间的转换：
```cpp
int ia[] = {1,2,3,4,5,6};
vector<int> v1(begin(ia), end(ia));  //整个数组
vector<int> v2(ia + 1, ia + 3);  // 部分数组
```

#### 多维数组
初始化：
```cpp
int ia[3][4] = {
{1, 2, 3, 4},
(1, 2, 3, 4),
{0, 1, 3, 5}
}

int ia[3][4] = {1, 2, 3, 4, 1, 2, 3, 4, 0, 1, 3, 5}; //和上面的等价

int ia[3][4] = {{1},{2},{3}};  // 初始化每行的第一个元素
int ia[3][4] = {1, 2, 3 ,4, 5};    // 初始化第一列和第二列的第一个元素
```
遍历：
```cpp
int a[3][4];
// 每次循环会取出一个长度为4的数组，所以这里使用数组的引用拿到被取出的数组
for(int (&row)[4] : a)   // int (&row)[4] = a[0];
     // 每次从数组中取出一个int值，这里使用int &拿到该值的引用
    for(int &v : row)    // int &v = row[n]
        v = 1;

// 等价于上面
for(auto &row : a)
    for(auto &v : row)
        v = 1;

//下面是一些不推荐的做法
for(int *row : a)  // 相当于int *row = a[0]

int arr[4];
for(int v : arr)   // int v = arr[n]，所以对v赋值并不能初始化arr中的元素
for(auto v : arr)  // 同上

```
以上这个循环将a数组中的每一个元素初始化为1，同时也列举了其他循环的写法，这些写法中推荐使用auto &来自动推断类型，或者自己写对引用类型。

#### 3.6练习
这个练习是C\++ Primer 第五版中的练习

```cpp
for (int(*p1)[4] = begin(a); p1 != end(a); p1++)
	for (int *p2 = begin(*p1); p2 != end(*p1); p2++)
		cout << *p2;
cout << endl;

for (size_t i = 0; i < 3; i++)
	for (size_t j = 0; j < 4; j++)
		cout << a[i][j];
cout << endl;

for (int(&row)[4] : a)
	for (int &v : row)
		cout << v;
cout << endl;

using int_array = int[4];
for (int_array &row : a)
	for (int &v : row)
		cout << v;
cout << endl;

for (auto &row : a)
	for (auto &v : row)
		cout << v;

```

###总结
之前一段时间总是把int &a和 &a搞混，声明的时候&是引用，右值的时候是取地址，int *p和*p和上面类似，声明的时候是指针，作为左值或者右值的时候是解引。其中a的类型是int &，p的类型是int *。所以符号位置不同含义不同，这下就不会混了。


















