---
title:        "C++学习笔记之二"
date:         2015-7-16 17:00
categories:   C++
tags:
- C++
---

阅读 《C++Primer 第四版》第四章 数组和指针 所做的一些笔记。

#<!--more-->

### 数组

数组的优势在于速度快，缺点在于没有vector的可伸缩性也没有类似size()的函数。

#### 数组的定义和初始化
定义数组时数组的维度必须是一个常量表达式，即要在编译器就可以确定的值。例如：
```cpp
const unsigned array_size = 3;
int a[array_size] = {0, 1, 2};
```
关于数组中元素的初始化：
* 函数体外定义的内置数组（内置数组就是C++内置的基本类型的数组），其元素均初始化为0
* 函数体内部的内置数组，则不做初始化
* 类类型的数组会自动调用无参构造方法，如果该类没有无参构造方法则需要在初始化的时候显示的初始化元素

显示初始化数组时不需要指定数组维度。
```cpp
int i[] = {1, 2, 3};
```
初始化字符数组有些不同：

```cpp
char c1[] = {'c', '+', '+'};  // length 3
char c2[] = {'c', '+', '+', '\0'}; // length 4
char c3[] = "c++";   // length 4
char c4[3] = "c++";  // error
```
c2和c3是结果是一样的，当用c3这种方式初始化char数组的时候，编译器会自动加入结束符，如果用c2的方式初始化就需要手动加一个结束符，像c1那样的初始化并不带结束符，打印输出的时候末尾会出现一些奇怪的字符。像c4初始化的时候维度应该是4不是3。

与vector不同一个数组不能用于另一个数组的初始化，也不能将一个数组赋值给另一个数组，例如：
```cpp
int i1[] = {1, 2, 3};
int i2[](i1); //error
int i3[3];
i3 = i1; //error
```
书上说有些编译器支持数组赋值数组（我尝试了g++和vs都不支持）。

#### 数组的操作
C++中的数组和java中的有一些区别，例如没办法直接拿到数组的长度。赋值能操作还是一样的。测量数组长度的方法如下。
```cpp
int aa[] = {1,2,3,4,5,6,7,8,9,0};
cout << sizeof(aa) / sizeof(int) << endl;
```
在C++中优先使用容器类，如果遇到必须数组才能解决的问题（例如性能）的时候再考虑用数组。

### 指针

指针用于指向对象，具体来说，指针保存了另一个对象的地址（和汇编中的立即寻址很像）：
```cpp
string s = "hahaha";
string *sp = &s;
```
&符号的意思是取地址，当他作用于一个对象的时候返回的是该对象存储的地址，取地址操作只能用于左值。


#### 指针的定义和初始化
常规风格：
```cpp
vector<int> *pvec;  //指向一个 vector<int> 对象
int *ip1, *ip2;     //指向 int 值
string *ps;         //指向string 对象
double dp1, *dp2;   // dp1是一个double值， *dp2是一个double值的指针
```
另一种风格：
```cpp
int* pi, i; // pi是个指针，i不是指针
int* pi1, *pi2;  //两个都是指针
```
个人还是习惯常规风格。

#### 指针的取值
未初始化的指针是无效的：
* 保存一个特定对象的地址
* 指向某个对象后面的另一个对象
* 0

```cpp
int ival = 1024;
int *pi = 0;  //不指向任何对象
int *pi2 = &ival //指向1024. pi2是ival的地址
int *pi3;  //未初始化的指针
pi = pi2;  // 指向同一个对象
pi2 = 0;   // 不指向任何对象，这里的0也可以是个常量表达式只要结果为0即可
pi2 = NULL; //等价于pi2 = 0
```
C++规范中并没有说明使用未初始化的指针会有什么问题，但是使用未初始化的指针式很危险的，未初始化的指针可能指向任意一个地址，当使用这个指针指向的数据时很有可能崩溃。测试vs2013中，未初始化的指针是会报编译期错误，g++中没有报错并且运行会打印一个地址。

总结一下对指针的理解：
```cpp
int i = 1;
int *pi = &i;  // pi的类型是int *也就是int指针,i的类型是int，指针类型中保存的被指向对象的地址，根据实际测试发现&i返回的就是int *类型。
```

#### void指针
void指针可以保存任何对象的地址：
```cpp
int i = 1;
void *vp = &i;
```
void指针并不清楚她保存的指针的对象类型，而且只支持有限的几个指针操作：
* 与另一个指针比较
* 传递函数指针
* 赋值给另一个void指针

#### 指针的操作
*操作符（解引操作符）将获取指针指向的对象：
```cpp
int *p = 0;
cout << *p << endl; // 程序崩溃
cout << p << endl;  // 指针地址 00000000

string str("sss");  // 初始化一个字符串
string *sp = &str;  
*sp = "asasda";     //*操作符（解引操作符）拿到的是str这个对象
```




