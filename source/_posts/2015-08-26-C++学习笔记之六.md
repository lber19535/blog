---
title:        "C++学习笔记之四"
date:         2015-8-26 17:00
categories:   C++
tags:
- C++
---

阅读 《C++Primer 第五版》第七章 类 所做的一些笔记。其中涉及到了抽象设计，结构体和类等相关的东西。

<!--more-->

本章就从定义和改进 Sales_data 这个类开始。

### 定义数据抽象类型
改进最初Sales_data的定义，**成员函数必须声明在内部，定义可以在内部也可以在外部。**
```cpp
struct Sales_data
{
	unsigned units_sold = 0;
	double revenue = 0.0;
	Sales_data &combine(const Sales_data &);
	double avg_price() const;  // 这里的 const 用法下面会讲
	string isbn() const {  //定义在类内部的函数是隐式的inline函数
		return bookNo;
	}
    string bookNo;
};

Sales_data add(const Sales_data &, const Sales_data &);
ostream &print(ostream &, const Sales_data &);
istream &read(istream &, Sales_data &);

int main(){
    Sales_data totaL;
}
```

#### this的作用
当我们在调用total.isbn()的时候，实际上他隐式的返回了total.bookNo。编译器在处理这个函数的时候会将函数变为类似下面的这种样子：
```cpp
Sales_data::isbn(&total)
```
这样在调用这个函数的时候total的地址就被传了过去，而this就是指向这个对象的指针，而且还是常量指针(因为无法修改他)：
```cpp
this->bookNo;
```
由于this的定义是隐式的，所以不能定义名为this的形参。

#### const成员函数
isbn 方法后紧跟的 const 是对 this 作用，不加 const 的时候，this的类型是Sales_data *const，也就是常量指针，即指针本身不能修改，如果加了 const 则变成了const Sales_data *const 类型，指向常量的常量指针，这样的好处就是没办法修改this的成员变量了。这种函数称为**常量成员函数**，如果想在它里面修改成员变量，需要将成员变量修改为 mutable 类型。

#### 作用域
类本身就是一个作用域，本届开始的时候 bookNo 被定义在了 isbn 方法的下面，但是这并不影响 isbn 方法中对他的使用，这是因为编译器在处理类的时候是分两步处理，先处理成员的声明(包括成员变量的声明，函数的声明)，然后再编译的函数体。

#### 定义成员函数
成员函数可以定义在类内部，也可以定义在类外部，例如下面是定义在类外部的avg_price方法：
```cpp
double Sales_data::avg_price() const {
	if (units_sold != 0)
	{
		return revenue / units_sold;
	}
	else {
		return 0;
	}
}
```
函数名 Sales_data::avg_price 中的 **::** 是作用域运算符，表示 avg_price 的作用域是 Sales_data。

#### 返回 this 对象
设计的时候由于没有操作符重载的知识，暂时只能用函数来代替。这一节定义了一个 combine 函数相当于 += ：
```cpp
Sales_data &Sales_data::combine(const Sales_data & r) {
	this->units_sold += r.units_sold;
	this->revenue += r.revenue;
	return *this;   // 解引得到对象
}
```

#### 定义类相关的非成员函数
add、print 和 read 虽然不属于 Sales_data 这个类，但是和他相关的非成员函数，一般这样的函数和类声明在同一个头文件中。

```cpp

```
















