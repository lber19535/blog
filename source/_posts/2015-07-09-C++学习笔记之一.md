---
title:        "C++学习笔记之一"
date:         2015-7-09 17:00
categories:   C++
tags:
- C++
---

阅读 《C++Primer 第四版》第三章 标准库类型 所做的一些笔记。

#<!--more-->

## 标准库类型

### string

#### string::size_type 

是STL中的一个配套类型，通过配套类型将整个库做到和平台无关，一般来说 size_type 基本和unsigned相同，大小是int的两倍，通常建议将string的size结果赋值给size_type而不要赋值给int。

#### string关系操作符

1.==,!= 比较两个string对象是否相等，相等的条件是长度相同且含有相同的字符（这个策略和java中的equals是相同的）。
2.>=,>,<,<= 大于，小于，大于等于，小于等于的判断策略是：
* 挨个比较每个字符的大小关系（区分大小写）,如果短的string和长的string前一部分相同，则长的string大于短的

``` cpp
string substr = "Hello";
string phrase = "Hello World";
string slang = "Hiya";

slang > phrase; // true
slang > substr; // true
substr < phrase // true
```
直接cout bool值的话只会输出只会输出0或1，想要输出true或false需要用到boolalpha:

``` cpp
bool b = true;
cout << b << endl; // 1
cout << std::boolalpha << b << endl; // true
```

#### string对象的赋值

大多数string的赋值等操作会有一些效率问题，例如
``` cpp
string s1, s2;
s1 = s2;
```
他需要把s1的相关内存释放掉，在分配给s1足够存放s2的内存空间，然后再把s2的内容复制到新的内存空间中（这里想到了指针）。

#### string的相加

``` cpp
string s1, s2;

s1 = s1 + s2;
s1 += s2; // 等价于上面
```

#### 和字符串字面值的连接

当使用+连接字符串的时候左右操作数必须有一个是string类型

```cpp
string s1, s2, s3;

string s4 = "a" + "b"; //error
string s5 = s1 + "a" + "b"; //ok
string s6 = "a" + "b" + s1; // error
```
大部分+的使用和java相同，区别就是上面所演示的，""在c++中是字符串(char*)，并不是string对象，所以根据[+的操作符](http://www.cplusplus.com/reference/string/string/operator+/)重载中定义的规则来看不支持s4和s6那样的操作，进一步的原因是因为操作符重载中的参数列表里必须有一个是类类型或枚举类型，而明显char*不符合条件，所以string的+左右才必须要有一个string类型。

#### 从string获取char

```cpp
string s = "12345";
char c = s[3]; // c=4
```

这里的[operator[]](http://www.cplusplus.com/reference/string/string/operator[]/)也是操作符重载，[]中的参数是size_t是一个无符号整形和size_type一样。

也可以这样当char*用：
```cpp
string str = "123456";
str[3] = '0'; // str=123056
```

#### cctype

字符处理的头文件包括判断大小写、是否是数字等常用功能，具体说明可以参考[文档](http://www.cplusplus.com/reference/cctype/)


#### string练习
对于3.9中的问题：

```cpp
string s;
cout << s[0] << endl;
```
这段代码在vs2013和gcc4.8中编译运行都未报错，虽然s[0]没有报错但是不能给s[0]赋值。后来尝试了如下代码：
```cpp
string s;
bool b = s.empty();
cout << boolalpha << b << endl; // true
cout << s[1] << endl; // print empty
```
这段代码在vs2013和gcc4.8下编译仍未报错，但是在在vs2013中运行的时候报了越界的错误，linux下gcc编译后运行未报错和s[0]效果一样。之后又在ubuntu gdb下做了调试发现，不管对s[index]中index如何改变，得到的结果都是一个"\000"的结束符，就算index为负数也不会报错（WTF！）。原因还需要再查查。

最后回答3.9这个问题，编译运行没报错，说明合法，但是这样写不合理。

### 标准库 vector
vector类似Java中的ArrayList，与之不太一样的地方是Vector的泛型可以直接用基本类型。

#### vector的初始化
```cpp
vector<int> ivec;
vector<Sales_Item> items;
vector<int> iivect(ivec); // copy of ivec
vector<int> v1(10,1); //十个值为1的item
vector<int> v2(10); //10个初始化的过的item
```
v2的原理是调用T的无参构造函数，如果没有无参构造函数则无法使用v2这种初始化vector。

#### vector对象的操作
常用方法有：
```cpp
v.empty() //如果是空返回true
v.size()  //返回一个size_type
v.push_stack(t) //在末尾插入一个item
v[n]  //返回index为n的元素
v1 = v2  //copy of v2
v1 == v2  //先比较vector的size，如果size相同，则使用每个item的==去比较对应的item
v1 < v2   //首先调用operator<，如果没有则去用Compare

```
对于没有重载operator\=\= 或 operator< 等的对象（一般是自定义的类）如果直接使用v1 \=\= v2或者 v1 < v2这样的方法会导致编译错误，编译器会提示需要重载所需的操作符。


