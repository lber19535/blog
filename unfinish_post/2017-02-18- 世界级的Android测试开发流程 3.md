---
title:        "世界级的Android测试开发流程 3"
date:         2017-02-18 17:00
categories:   Android
list_number:  false
tags:
- C++
---

翻译自[世界级的Android测试开发流程系列第三篇](http://blog.karumi.com/world-class-testing-development-pipeline-for-android-part-3/)。前两篇可以看这里，[第一篇](http://blog.zhaiyifan.cn/2016/02/23/world-class-testing-development-pipeline-for-android-part-1/)，[第二篇](http://blog.zhaiyifan.cn/2016/02/23/world-class-testing-development-pipeline-for-android-part-2/)。由于看到这个文章时还没有人翻译后两篇，所以就自己动手了。

<!--more-->

在第二篇中我们讨论了测试业务逻辑，也就是系列文章的第一部分。我们讨论了如何用依赖倒置原则来测试我们的代码并得到以下结论：

* 测试替身（Test Doubles）用来模拟不同组件的行为，选择对应部分的测试创建独立的测试环境。
* 测试替身用来验证组件之间协作
* 依赖倒置原则可以帮助我们使用测试替身来替换生产环境的代码
* 测试基于状态而不是行为，组件之间应该是松耦合的

在这篇文章中，我们会在如何和远端服务测试集成的主题中回顾一些第二篇中提到的测试方法。大多数的移动应用程序是基于服务端 API 的。这些服务或者是 API 用来存取数据。没有这些服务，APP 就无法使用。在 2016 年，大多数的 Android 和 iOS 程序仅仅是显示那些从服务端或者缓存得到信息的前端。然而使用内部服务进行集成是应用开发中的一个关键点。我们需要确保我们的代码发送了正确的数据给 API 并且正确解析的 API 的返回值。如果你的程序使用了身份验证，那么测试 API 就显得更为重要，因为如果验证失败就会无法使用。

# 1.测试服务端 API
当处理服务端 API 集成的时候，我们需要知道客户端的是否做到以下几点：

* 发送了正确的消息给 API
* 响应（responses）解析正确
* 实现合适的身份验证机制
* 正确处理 API 的错误

为了验证这写假设，我们需要模拟不同的服务端响应和根据请求执行不同的断言。为了测试客户端工作是否达到预期，我们需要使用测试替身和根据网络发送的消息执行断言。在这个例子中，我们将用替身测试中的 [Mock](https://www.martinfowler.com/bliki/TestDouble.html) 和第三方的工具 [MockWebServer](https://github.com/square/okhttp/tree/master/mockwebserver)。

MockWebServer 是一个脚本化的 Web Server，它是 Square 用 Java 实现的，用来测试 HTTP 客户端。达到目标最基本的方式是写一些预先配置好的 HTTP 响应，并通过 HTTP 请求执行断言。
McokWebServer 会启动一个内置的 HTTP 服务，将我们的 API host 改为 MockWebServer 并且配置一些 HTTP 响应，接下来我们就能测试我们的 API 了。这个 lib 以 mock 的方式工作，但是在客户端这边不用替换生产环境的代码。

我们使用一个电商的小程序来演示。我们将集中在这三点：身份验证机制，重新建立的 session 的过程和 JSON 的解析。身份验证和 seesion 重建是基于两个 token 和邮箱/密码系统，客户端可以更新 token 以使其不会过期。

```java
public class RenewSessionTest extends ApiClientTest<BaseApiClient> {

  @Test public void shouldKeepTheUserLoggedInAfterRenewSession() {
    performLogin();
    enqueueUnauthorizedResponse();
    enqueueUnauthorizedResponse();
    enqueueSessionRenewedResponse();
    enqueueResponse();

    HttpRequest request = HttpRequest.Builder.to(ANY_ENDPOINT).get();
    getApiClient().send(request, AnyResponse.class);

    assertTrue(getApiClient().isUserLoggedIn());
  }

  @Test public void shouldSendRequestAfterRenewSessionUsingTheNewAccessToken() {
    performLogin();
    enqueueUnauthorizedResponse();
    enqueueSessionRenewedResponse();
    enqueueResponse();

    HttpRequest request = HttpRequest.Builder.to(ANY_ENDPOINT).get();
    getApiClient().send(request, AnyResponse.class);

    assertRequestContainsHeader(ACCESS_TOKEN_KEY, NEW_ACCESS_TOKEN); 
  }
}
```

在这些测试中我们可以看到关于 API 的测试。在测试 API 之前我们要先配置一些 HTTP 的 response。我们创建了一个用户在使用认证 API 时的场景，并发送一个请求道后端。服务端回复一个认证失败的 response。这样就可以测试重建一个 session 的流程，当 token 还是有效的时候客户端应该使用一个长期的 token 来重建 session，当过期的时候需要用户重新认证。在测试执行的最后，我们需要判断用户是否登陆上了，还是这个 request 在重建 session 时再次被用来获取新的 token。有一点需要注意的是有当 request 多于预先配置的 response 时测试就会失败。

```java
public class CartApiClientTest extends ApiClientTest<CartApiClient> {

  @Test public void shouldObtainCartFromTheCartEndpoint() {
    enqueueResponse(GET_CART_RESPONSE_FILE);

    CartDTO cart = givenACartApiClient().getCart();

    assertCartContainsExpectedValues(cart);
  }

  @Test public void shouldParseAddToCartResponse() {
    enqueueResponse(ADD_TO_CART_RESPONSE);

    CartDTO cart = givenACartApiClient().addToCart(ANY_SKU_ID);

    assertCartContainsExpectedValuesAfterAddAnItem(cart);
  }

  @Test public void shouldParseUpdateLineResponse() {
    enqueueResponse(UPDATE_CART_LINE_RESPONSE_FILE);

    CartDTO cart = givenACartApiClient().updateLine(ANY_SKU_ID, 3);

    assertCartContainsExpectedValuesAfterLineUpdated(cart);
  }
}
```
如前所述


```java
public abstract class ApiClientTest<T extends BaseApiClient> {

  private MockWebServer server;
  private T apiClient;

  @Before public void setUp() throws Exception {
    this.server = new MockWebServer();
    this.server.start();
    apiClient = initializeApiClient();
  }

  @After public void tearDown() throws IOException {
    server.shutdown();
  }

  protected void enqueueResponse(String fileName) throws IOException {
    MockResponse mockResponse = new MockResponse();
    String fileContent = getContentFromFile(fileName);
    mockResponse.setBody(fileContent);
    server.enqueue(mockResponse);
  }

  protected void enqueueUnauthorizedResponse() {
    MockResponse mockResponse = new MockResponse();

    mockResponse.setResponseCode(UNAUTHORIZED_CODE);
    server.enqueue(mockResponse);
  }

  protected void assertNumberOfRequestSent(int numberOfRequests) {
    assertEquals(numberOfRequests, server.getRequestCount());
  }


  protected void assertRequestContainsHeader(String key, String expectedValue, int requestIndex)
      throws InterruptedException {
    RecordedRequest recordedRequest = getRecordedRequestAtIndex(requestIndex);
    String value = recordedRequest.getHeader(key);
    assertEquals(expectedValue, value);
  }


  protected void assertPostRequestSentTo(String url) throws InterruptedException {
    RecordedRequest request = server.takeRequest();
    assertEquals(url, request.getPath());
    assertEquals(POST_METHOD, request.getMethod());
  }
}
```


# 4.结论
当我们 Mock server 端的 API 的时候我们可以简单的复现不同的场景，检查我们的客户端的实现是否符合响应的预期。同时，我们做了一个关于 server 端 api 的文档。我们也可以用这些 test case 去复现一些比较少见的问题，例如获取的响应不完整或是网络状况不好。当我们给业务层做好测试，我们可以创建一个独立的环境，让我们的测试可以被复用，可以做更好的设计。
如果想要查看关于客户端的实现可以查看他们的两个开源项目，一个是 [Java](https://github.com/Karumi/MarvelApiClientAndroid/) 的一个是 [Swift](https://github.com/Karumi/BothamNetworking) 的。

